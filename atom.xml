<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Noloty Land</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://NolotyLand.github.io/"/>
  <updated>2020-01-12T02:28:00.398Z</updated>
  <id>http://NolotyLand.github.io/</id>
  
  <author>
    <name>Noloty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Elasticsearch】docker安装步骤</title>
    <link href="http://NolotyLand.github.io/Note-ElasticSearch-install/"/>
    <id>http://NolotyLand.github.io/Note-ElasticSearch-install/</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-01-12T02:28:00.398Z</updated>
    
    <content type="html"><![CDATA[<p>简略记录一下命令</p>  <a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:版本号</span><br></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name=es -p 9300:9300 -p 9200:9200 elasticsearch:版本号</span><br></pre></td></tr></table></figure><p>运行参数：<br>-p :对宿主机和容器的端口进行映射，冒号前的是宿主机端口，冒号后的是容器端口<br>-d :后台运行<br>-i :打开STDIN，用于控制台交互<br>–name :对容器命名</p><h2 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h2><p>浏览器访问 http://宿主机ip:9300<br>或者控制台输入 curl http://宿主机ip:9300<br>如果能正常返回如下图所示的json信息即为安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;D2S3pza&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;DNX8puJET4G6JbcAyM_68Q&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.7.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;8453f77&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-03-21T15:32:29.844721Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.7.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简略记录一下命令&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>【Kibana】docker安装步骤</title>
    <link href="http://NolotyLand.github.io/Note-Kibana-install/"/>
    <id>http://NolotyLand.github.io/Note-Kibana-install/</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-01-12T02:02:30.130Z</updated>
    
    <content type="html"><![CDATA[<p>简略记录一下命令</p>  <a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana:7.5.0</span><br></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mykibana -p 5601:5601 -d docker.elastic.co/kibana/kibana:7.5.0</span><br></pre></td></tr></table></figure><p>运行参数：<br>-p :对宿主机和容器的端口进行映射，冒号前的是宿主机端口，冒号后的是容器端口<br>-d :后台运行<br>–name :对容器命名</p><p>进入容器<br>cd config<br>会看到有名为kibana.yml的配置文件<br>需要把<a href="http://elasticsearch:9200" target="_blank" rel="noopener">http://elasticsearch:9200</a> 修改成正确的ip和端口<br><img src="https://raw.githubusercontent.com/nolopic/pictures/master/20200112084449.png" alt><br>￼</p><h2 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h2><p>浏览器访问 http://宿主机ip:5601</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简略记录一下命令&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>【常用】正则表达式</title>
    <link href="http://NolotyLand.github.io/regex/"/>
    <id>http://NolotyLand.github.io/regex/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2019-09-12T17:32:24.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“-s-”"><a href="#“-s-”" class="headerlink" title="“\s+”"></a>“\s+”</h2><p>\s+ 匹配多个空白字符</p><p>包括下面几个:<br>\f -&gt; 匹配一个换页<br>\n -&gt; 匹配一个换行符<br>\r -&gt; 匹配一个回车符<br>\t -&gt; 匹配一个制表符<br>\v -&gt; 匹配一个垂直制表符</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;“-s-”&quot;&gt;&lt;a href=&quot;#“-s-”&quot; class=&quot;headerlink&quot; title=&quot;“\s+”&quot;&gt;&lt;/a&gt;“\s+”&lt;/h2&gt;&lt;p&gt;\s+ 匹配多个空白字符&lt;/p&gt;
&lt;p&gt;包括下面几个:&lt;br&gt;\f -&amp;gt; 匹配一个换页&lt;br&gt;\n -&amp;gt;
      
    
    </summary>
    
      <category term="糖" scheme="http://NolotyLand.github.io/categories/%E7%B3%96/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>未分类Tips</title>
    <link href="http://NolotyLand.github.io/Other-tips/"/>
    <id>http://NolotyLand.github.io/Other-tips/</id>
    <published>2019-06-29T16:00:00.000Z</published>
    <updated>2019-09-18T03:34:53.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="软连接和硬链接"><a href="#软连接和硬链接" class="headerlink" title="软连接和硬链接"></a>软连接和硬链接</h2><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><p>是一个保存了指向文件路径的特殊文件，相当于windows里的快捷方式</p><p>创建语法  ln -s 文件路径 链接名<br>  For Example:</p><blockquote><p>ln -s Noloty-PROJECT/blog/  bloglink</p></blockquote><p> 删除软链接：</p><blockquote><p>rm -rf  /home/zhenwx/htccode 注意不是rm -rf  /home/zhenwx/htccode/ （这个是删除目录下的文件）</p></blockquote><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>是一个指向文件索引节点(Inode Index)的指针, 当删除文件时, 如果存在指向这个文件的硬链接, 这个文件就不会被真实删除。除非所有硬链接都被删除，这个文件才会被真正删除。所以硬链接有个重要作用就是防误删。</p><p>创建语法  ln 文件路径 链接名</p><p>For Example:</p><blockquote><p>ln Noloty-PROJECT/blog/  bloglink</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noopener">Linux软连接和硬链接</a></p><h2 id="debian修改系统时区"><a href="#debian修改系统时区" class="headerlink" title="debian修改系统时区"></a>debian修改系统时区</h2><p>会记录这个是因为使用Docker安装jenkins之后，发现构建项目时出现的时区不对。<br>而构建时间是使用了docker容器内的系统时区。<br>使用的镜像是debian9系统。</p><p>如果手动修改，可使用下述命令，列出地区任你选择。</p><blockquote><p>dpkg-reconfigure tzdata</p></blockquote><p>此命令会修改两个文件</p><blockquote><p>/etc/timezone #该文本文件可直接修改<br>/etc/localtime #该文件可通过软连接修改</p></blockquote><p>所以如果在脚本里使用命令行修改可使用下述命令</p><blockquote><p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>echo Asia/Shanghai &gt; /etc/timezone </p></blockquote><p>另外:</p><blockquote><p>date # 列出当前系统时间<br>date -R # 列出当前系统时区</p></blockquote><h2 id="修改Jenkins的系统时间"><a href="#修改Jenkins的系统时间" class="headerlink" title="修改Jenkins的系统时间"></a>修改Jenkins的系统时间</h2><p>打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</p><blockquote><p>System.setProperty(‘org.apache.commons.jelly.tags.fmt.timeZone’, ‘Asia/Shanghai’)<br>System.setProperty(‘user.timezone’, ‘Asia/Shanghai’)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;h2 id=&quot;软连接和硬链接&quot;&gt;&lt;a href=&quot;#软连接和硬链接&quot; class=&quot;headerlink&quot; title=&quot;软连接
      
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="tips" scheme="http://NolotyLand.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins使用记录(Centos7)</title>
    <link href="http://NolotyLand.github.io/Tool-Jenkins/"/>
    <id>http://NolotyLand.github.io/Tool-Jenkins/</id>
    <published>2019-06-24T16:00:00.000Z</published>
    <updated>2019-07-05T11:25:16.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>一般来说，软件的开发流程大致分为下面几个步骤<br>设计 开发 构建 测试 部署<br>尝试过手动部署的话就会知道，这一次次的重复动作并不令人愉快，而Jenkins就可以帮助程序员自动化构建、测试、部署这几个步骤，只要提交代码到git,或者其它代码管理工具上，Jenkins便可以执行预先编写的脚本，自动完成构建到部署的一系列步骤，让程序员专注于开发。</p>  <a id="more"></a><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>机器配置建议内存2G以上<br>虽然官方说256M也可以，但是一构建项目就会发现不够用了</p><p>Dockerfile:</p><blockquote><pre><code># 官方镜像似乎很久没更新了，版本太低，很多插件装不上。所以用了这个版本   FROM jenkins/jenkins:lts   USER root   RUN apt-get update \     &amp;&amp; apt-get install -y sudo \     &amp;&amp; apt-get install -y maven \     &amp;&amp; apt-get install -y git \     &amp;&amp; apt-get install -y ssh \     &amp;&amp; apt-get install -y vim \     &amp;&amp; rm -rf /var/lib/apt/lists/* \     &amp;&amp; git config --global user.name name \     &amp;&amp; git config --global user.email email \     &amp;&amp; echo &quot;jenkins ALL=NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers \     &amp;&amp; mkdir /root/.ssh   EXPOSE 8080   EXPOSE 50000</code></pre></blockquote><p>镜像制作:</p><blockquote><p>   docker build -t jenkins-image .</p></blockquote><p>启动参数:</p><blockquote><p>   docker run -p 80:8080 -p 50000:50000  -v /var/jenkins_home:/var/jenkins_home -v -d  jenkins-image</p></blockquote><p>启动参数(考虑到Jenkins执行docker和使用ssh的情况):</p><blockquote><p>   docker run -p 80:8080 -p 50000:50000  -v /var/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock  -v ~/.ssh:/root/.ssh  -v /usr/bin/docker:/usr/bin/docker  –group-add $(stat -c ‘%g’ /var/run/docker.sock) -d jenkins-image</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>首先要说明一下，Jenkins采用Master/Salve架构, Jenkins所在的服务器为Master, 可通过配置将其它服务器作为Salve，将服务发布到不同的服务器上。<br>因此，如果想要在远程服务器上部署服务，就有了2种选择</p><ol><li>在Master机器上拉取代码进行构建，编译成功后执行脚本，将打包好的软件通过ssh传输到其它机器上。</li><li>配置Salve机器，通过Jenkins控制，在Salve机器上直接进行拉取代码、构建、部署操作。</li></ol><p>由于构建还算是个比较耗内存的操作，我这里选择了第一种方法，这样只把Master机的内存配高点就行了。</p><ol><li><p>打开jenkins管理页面, 新建任务, 选择第一个，“构建自由风格的软件项目”，有特殊需求可以选其它的。<br><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190629161240.png" alt></p></li><li><p>源码管理中填入<br><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190701171037.png" alt><br>根据自己情况使用SSH或者账号密码</p></li></ol><p>3.最后写入构建时执行的脚本<br><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190701171247.png" alt></p><p>Example：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">scp -r target/boot-web-0.0.1-SNAPSHOT.jar user@X.X.X.X:boot-web.jar </span><br><span class="line">OUT=$?</span><br><span class="line">if [ $OUT = 0 ]; then</span><br><span class="line">  echo 'transfer boot-web.jar successful'</span><br><span class="line">else</span><br><span class="line">  echo 'transfer boot-web.jar faild'</span><br><span class="line">fi</span><br><span class="line">ssh -tt user@X.X.X.X "/root/reset-boot-web.sh"</span><br></pre></td></tr></table></figure><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><h2 id="构建时报错-FileNotFoundException"><a href="#构建时报错-FileNotFoundException" class="headerlink" title="构建时报错 FileNotFoundException"></a>构建时报错 FileNotFoundException</h2><blockquote><pre><code>java.io.FileNotFoundException      at jenkins.plugins.git.GitSCMFile$3.invoke(GitSCMFile.java:173)      ...</code></pre><p><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190625042230.png" alt></p></blockquote><p>原因: JenkinsFile未创建或未放到正确的位置</p><p>解决方法:<br>     JenkinsFile放到项目根目录下, 注意不能放到任何子目录下<br>For Example:<br>     .<br>     ├── .setting<br>     ├── project<br>     └── Jenkinsfile</p><h2 id="构建时报错-docker-not-found"><a href="#构建时报错-docker-not-found" class="headerlink" title="构建时报错 docker: not found"></a>构建时报错 docker: not found</h2><pre><code>/var/jenkins_home/workspace/Pipe2@tmp/durable-7a5cbc08/script.sh: 1: /var/jenkins_home/workspace/Pipe2@tmp/durable-7a5cbc08/script.sh: docker: not found</code></pre><p> <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190625051013.png" alt></p><p>原因: 此脚本里需要执行docker命令，但在Jenkins所在的容器内未找到docker命令, 需要将宿主机的docker命令关联到jenkins容器上</p><p>解决方法:<br>在 jenkins容器的启动参数里加上 -v $PWD/var/run/docker.sock:/var/run/docker.sock -v 宿主机docker路径:/usr/bin/docker<br>详细解释见 <a href="https://blog.csdn.net/kikajack/article/details/79806520" target="_blank" rel="noopener">这里</a></p><p>For Example:</p><blockquote><pre><code>docker run -p 80:8080 -p 50000:50000  -v /var/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker  --group-add $(stat -c &apos;%g&apos; /var/run/docker.sock) -d  jenkins-image</code></pre></blockquote><h2 id="构建时报错-docker-Permission-denied"><a href="#构建时报错-docker-Permission-denied" class="headerlink" title="构建时报错 docker: Permission denied"></a>构建时报错 docker: Permission denied</h2><p>原因: Jenkins容器的用户没有操作宿主机docker的权限<br>注: Jenkins想要在自身所在的容器内使用docker命令，一般有两种方式，一种是在容器内重新安装docker, 被称之为DinD(Docker-in-Docker)。<br>    另一种是与宿主机的docker命令关联，使用宿主机的docker，被称之为DonD(Docker-outside-of-Docker).<br>    如果使用DonD的方式，就需要给Jenkins用户添加使用宿主docker的权限。</p><p>解决方法(DonD): </p><p> Dockerfile增加下述命令</p><blockquote><p>   RUN apt-get update <br>       &amp;&amp; apt-get install -y sudo <br>       &amp;&amp; rm -rf /var/lib/apt/lists/* <br>       &amp;&amp; echo “jenkins ALL=NOPASSWD: ALL” &gt;&gt; /etc/sudoers  </p></blockquote><p> 并且使用docker run 命令时增加 -v /usr/bin/docker:/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock 参数</p><h2 id="报错无法获得连接套接字权限"><a href="#报错无法获得连接套接字权限" class="headerlink" title="报错无法获得连接套接字权限"></a>报错无法获得连接套接字权限</h2><blockquote><p>   Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/json?all=1: dial unix /var/run/docker.sock: connect: permission denied</p></blockquote><p>原因 : 宿主机的docker用户和容器内的docker用户gid不同，导致套接字未能识别</p><p>解决方法: 运行参数中加上 –group-add $(stat -c ‘%g’ /var/run/docker.sock)</p><p>For Example:</p><blockquote><pre><code>docker run -p 80:8080 -p 50000:50000  -v $PWD/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker  --group-add $(stat -c &apos;%g&apos; /var/run/docker.sock) -d  jenkins-image</code></pre></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b524b151d35f" target="_blank" rel="noopener">Jenkins使用简易教程</a></p><p><a href="https://hub.docker.com/r/jenkins/jenkins" target="_blank" rel="noopener">jenkins/jenkins:lts镜像地址</a></p><p><a href="http://www.dockone.io/article/431" target="_blank" rel="noopener">在（Docker里的）Jenkins里运行Docker</a></p><p><a href="https://blog.csdn.net/kikajack/article/details/79806520" target="_blank" rel="noopener">采用容器安装 Jenkins 的踩坑记录（基于 Centos7）</a></p><p><a href="http://www.up4dev.com/2018/11/27/run-docker-by-jenkins-in-docker/" target="_blank" rel="noopener">用安装在 Docker 中的 jenkins 运行 Docker 任务</a></p><p><a href="https://github.com/jenkinsci/docker/issues/263" target="_blank" rel="noopener">Use docker inside docker with jenkins user</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/7102622.html" target="_blank" rel="noopener">Jenkins : 安装 master 和 slave</a></p><p><a href="https://blog.csdn.net/achenyuan/article/details/86644954" target="_blank" rel="noopener">jenkins分布式构建和部署(master-slave)</a></p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">什么是CI/CD?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;一般来说，软件的开发流程大致分为下面几个步骤&lt;br&gt;设计 开发 构建 测试 部署&lt;br&gt;尝试过手动部署的话就会知道，这一次次的重复动作并不令人愉快，而Jenkins就可以帮助程序员自动化构建、测试、部署这几个步骤，只要提交代码到git,或者其它代码管理工具上，Jenkins便可以执行预先编写的脚本，自动完成构建到部署的一系列步骤，让程序员专注于开发。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://NolotyLand.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tool" scheme="http://NolotyLand.github.io/tags/tool/"/>
    
      <category term="jenkins" scheme="http://NolotyLand.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>【踩坑】错误使用SimpleDateFormat导致的并发bug排查历程</title>
    <link href="http://NolotyLand.github.io/Bugs-date/"/>
    <id>http://NolotyLand.github.io/Bugs-date/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2020-01-12T01:23:56.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>  之前某系统定时任务程序，偶尔会发生日期错误的现象。<br>  应该是当天记录的信息，但展示的日期却差了几个月。</p>   <a id="more"></a><h1 id="探索过程"><a href="#探索过程" class="headerlink" title="探索过程"></a>探索过程</h1><p>  首先要确认是信息创建时便有这种情况，还是创建之后其它程序修改时造成的。<br>  通过日志得知，时间在创建时便已经异常了。出现概率大概在1/500~1/1000。<br>  然而整个创建过程逻辑并不复杂，并未发现有什么可疑代码。</p><p>  本着先复现再排查的原则。在测试环境将此定时任务循环跑了几千条，然后不断缩小范围，发现最终原因出现在创建日期使用的工具类上。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>这里写个类模拟当时的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date(<span class="number">1546300800000L</span>);</span><br><span class="line">                String ymd = sdf.format(date);</span><br><span class="line">                <span class="keyword">if</span>(!ymd.equals(<span class="string">"2019-01-01"</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">"get wrong date :"</span> + ymd);</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"01 thread "</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">               Date date = <span class="keyword">new</span> Date(<span class="number">1549065600000L</span>);</span><br><span class="line">               String ymd = sdf.format(date);</span><br><span class="line">               <span class="keyword">if</span>(!ymd.equals(<span class="string">"2019-02-02"</span>)) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()  + <span class="string">"get wrong date :"</span> + ymd);</span><br><span class="line">                   System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">"02 thread "</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><pre><code>02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------01 thread get wrong date :2019-02-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------02 thread get wrong date :2019-01-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------...</code></pre><p>究其原因，是因为SimpleDateFormat类并非线程安全的类，将其定义为静态变量时，在并发情况下极有可能拿到其它线程的日期数据。<br><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">官网文档</a>也写到，在多线程的情况下，必须在外部进行同步处理。</p><blockquote><p>Synchronization<br>  Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>两种解决方法<br>一种是将静态的SimpleDateFormat改为每次都使用新的对象，如上面格式化日期那一句改成这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1546300800000L</span>);</span><br><span class="line">String ymd = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(date);</span><br></pre></td></tr></table></figure><p>另一种是使用JDK8新提供的的日期类，LocalDate或者LocalDateTime代替Date, DateTimeFormatter代替SimpleDateFormat, 简单，优雅，线程安全:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-02-02"</span>);</span><br><span class="line">String ymd = date.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h1&gt;&lt;p&gt;  之前某系统定时任务程序，偶尔会发生日期错误的现象。&lt;br&gt;  应该是当天记录的信息，但展示的日期却差了几个月。&lt;/p&gt;
    
    </summary>
    
      <category term="bug" scheme="http://NolotyLand.github.io/categories/bug/"/>
    
    
      <category term="bug" scheme="http://NolotyLand.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的各种遍历方式</title>
    <link href="http://NolotyLand.github.io/JI-hashmap-traverse/"/>
    <id>http://NolotyLand.github.io/JI-hashmap-traverse/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-07-08T01:24:56.901Z</updated>
    
    <content type="html"><![CDATA[<p>关于性能，网上是这么说的：<br>entrySet方法一次拿到所有key和value的集合<br>而keySet拿到的只是key的集合，针对每个key，都要去Map中额外查找一次value，从而降低了总体效率<br>所以大数据量时。entrySet的方式效率更高。<br>(10w级以上才会出现明显差别，一般不考虑）<br>最优方法还是lambda表达式，简洁而且性能好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">"1"</span>,<span class="string">"1111"</span>);</span><br><span class="line">      map.put(<span class="string">"2"</span>,<span class="string">"2222"</span>);</span><br><span class="line">      map.put(<span class="string">"3"</span>,<span class="string">"3333"</span>);</span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 只遍历value:</span></span><br><span class="line">      <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">          System.out.println(value);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      <span class="comment">//key value都遍历:</span></span><br><span class="line">      <span class="comment">// 遍历keySet</span></span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">          System.out.println(key + <span class="string">":"</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 遍历entrySet</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">          System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      <span class="comment">// entrySet集合迭代器遍历</span></span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">          System.out.println( entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// forEach方法+lambda表达式（底层也是entrySet遍历）(jdk1.8+  )</span></span><br><span class="line">      map.forEach((k, v) -&gt;  System.out.println( k + <span class="string">":"</span> + v));</span><br></pre></td></tr></table></figure><p>顺带一提List和Set的遍历方式, 是一样的, 由于跟Map比起来没什么复杂度估计一般不会问到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//forEach+lambda遍历（底层就是for循环遍历）（jdk1.8+）</span></span><br><span class="line">     list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"======================"</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//for循环遍历</span></span><br><span class="line">     <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//集合迭代器遍历</span></span><br><span class="line">     Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">     <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">         System.out.println(it.next());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//forEach+lambda遍历（底层就是for循环遍历）（jdk1.8+）</span></span><br><span class="line">      set.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//for循环遍历</span></span><br><span class="line">      <span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//集合迭代器遍历</span></span><br><span class="line">      Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">          System.out.println(it.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于性能，网上是这么说的：&lt;br&gt;entrySet方法一次拿到所有key和value的集合&lt;br&gt;而keySet拿到的只是key的集合，针对每个key，都要去Map中额外查找一次value，从而降低了总体效率&lt;br&gt;所以大数据量时。entrySet的方式效率更高。&lt;br&gt;(
      
    
    </summary>
    
      <category term="面试" scheme="http://NolotyLand.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="java" scheme="http://NolotyLand.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>后端工具</title>
    <link href="http://NolotyLand.github.io/JI-backend-knowledge/"/>
    <id>http://NolotyLand.github.io/JI-backend-knowledge/</id>
    <published>2019-06-18T16:00:00.000Z</published>
    <updated>2019-06-26T20:27:42.895Z</updated>
    
    <content type="html"><![CDATA[<br><h1 id="MVC的技术应用"><a href="#MVC的技术应用" class="headerlink" title="MVC的技术应用"></a>MVC的技术应用</h1><table><thead><tr><th align="center"></th><th align="center">应用</th></tr></thead><tbody><tr><td align="center">M</td><td align="center">servlet、struts</td></tr><tr><td align="center">V</td><td align="center">jsp、FreeMarker Velocity</td></tr><tr><td align="center">C</td><td align="center">herbernate、ibatis mybatis</td></tr></tbody></table><br><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><table><thead><tr><th align="center">工具</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Mybatis</td><td align="center">持久层框架</td></tr><tr><td align="center">jenkins</td><td align="center">Jenkins是一款 CI&amp;CD （ Continuous Integration 持续集成 &amp; Continuous Delivery 持续交付 ）软件，用于自动化各种任务，包括构建、测试和部署软件。</td></tr><tr><td align="center">docker</td><td align="center">Docker 是一个应用容器引擎</td></tr><tr><td align="center">tomcat</td><td align="center">Servlet容器</td></tr><tr><td align="center">spring</td><td align="center">Spring是一个开发应用框架，其目的是用于简化企业级应用程序开发</td></tr><tr><td align="center">git</td><td align="center">git是一种分布式的版本管理系统</td></tr><tr><td align="center">GitHub</td><td align="center">GitHub是基于git的代码库托管网站，主要作用是开源代码发布及托管</td></tr><tr><td align="center">Maven</td><td align="center">Maven是一个项目管理和构建工具，主要做编译、测试、报告、打包、部署等操作完成项目的构建</td></tr><tr><td align="center">IntelliJ IDEA</td><td align="center">Java集成开发环境</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br&gt;


&lt;h1 id=&quot;MVC的技术应用&quot;&gt;&lt;a href=&quot;#MVC的技术应用&quot; class=&quot;headerlink&quot; title=&quot;MVC的技术应用&quot;&gt;&lt;/a&gt;MVC的技术应用&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo中markdown文件生成的HTML页面白屏</title>
    <link href="http://NolotyLand.github.io/hexo-fix-whitescreen/"/>
    <id>http://NolotyLand.github.io/hexo-fix-whitescreen/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2020-01-12T01:15:03.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象·起因"><a href="#现象·起因" class="headerlink" title="现象·起因"></a>现象·起因</h2><p>   写了几篇文章草稿，本地测试发布发现偶尔会有文章页面白屏，无法加载出任何内容。有时删除或者增加一些字会能够正常加载页面。</p>   <a id="more"></a><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/white.png" alt></p><p>   一开始以为是文章内容里有特殊符号与页面渲染插件冲突造成的，但排查了文章内容后，并未发现有比较特殊的符号。<br>   删除一些文字能够正常渲染页面，但这些文字并无特殊之处。</p><p>   检查页面源代码时，才发现原因，原来出问题的页面代码未加载完就被截断了。</p><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190614015626.png" alt></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>   参考 <a href="https://molunerfinn.com/make-a-hexo-theme/#Bug%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3" target="_blank" rel="noopener">Hexo主题开发经验杂谈</a><br>   此问题属于hexo的bug，在中文字符过多时会有几率显现。<br>   在hexo目录下的_config.yml里添加如下配置可以避免：</p><pre><code class="yml"><span class="attr">server:</span><span class="attr">  compress:</span> <span class="literal">true</span> <span class="comment"># 开启压缩</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象·起因&quot;&gt;&lt;a href=&quot;#现象·起因&quot; class=&quot;headerlink&quot; title=&quot;现象·起因&quot;&gt;&lt;/a&gt;现象·起因&lt;/h2&gt;&lt;p&gt;   写了几篇文章草稿，本地测试发布发现偶尔会有文章页面白屏，无法加载出任何内容。有时删除或者增加一些字会能够正常加载页面。&lt;/p&gt;
    
    </summary>
    
      <category term="坑" scheme="http://NolotyLand.github.io/categories/%E5%9D%91/"/>
    
    
      <category term="hexo" scheme="http://NolotyLand.github.io/tags/hexo/"/>
    
      <category term="fix" scheme="http://NolotyLand.github.io/tags/fix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插件上的踩坑记录</title>
    <link href="http://NolotyLand.github.io/hexo-plugin/"/>
    <id>http://NolotyLand.github.io/hexo-plugin/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2020-01-12T02:26:36.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h1><p>这里只列出遇到过的问题，如未找到解决方法可到<a href="https://github.com/gitalk/gitalk/issues" target="_blank" rel="noopener">Gitalk issues</a> 寻找解决方法，或提出issue</p>  <a id="more"></a><h2 id="评论系统出现-Error-Not-found"><a href="#评论系统出现-Error-Not-found" class="headerlink" title="评论系统出现 Error:Not found."></a>评论系统出现 Error:Not found.</h2><p><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190622063211.png" alt></p><p>可能原因:配置格式不对, 示例如下</p><pre><code>client_id: &apos;XXX&apos;client_secret: &apos;XXX&apos;repo: &apos;NolotyLand.github.io&apos;owner: &apos;NolotyLand&apos;admin: &apos;NolotyLand&apos;</code></pre><h2 id="评论系统出现-Related-issues-not-found"><a href="#评论系统出现-Related-issues-not-found" class="headerlink" title="评论系统出现 Related issues not found"></a>评论系统出现 Related issues not found</h2><p><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190622080725.png" alt></p><p>可能原因:</p><ol><li><p>github仓库 issues未勾选</p><p> 仓库-&gt;Setting-&gt;Features-&gt;issues<br> <img src="https://raw.githubusercontent.com/nolopic/pictures/master/20200112095540.png" alt></p></li><li><p>GitHub Application配置错误<br> <a href="https://github.com/settings/applications" target="_blank" rel="noopener">GitHub Application</a>里，Authorization callback URL拼写错误，示例如下，注意最后带/</p><p> <a href="https://nolotyland.github.io/">https://nolotyland.github.io/</a></p></li><li><p>没有初始化（一段时间不用就很容易忘记这点）</p><p> 比较麻烦的一点就是gittalk每篇文章新发布后，都需要你登录github账号，进入文章页面，用以对评论进行初始化。<br> 登录后看到正常的评论框后，即为初始化完成，退出登录后也依然可以看到评论看。<br> <img src="https://raw.githubusercontent.com/nolopic/pictures/master/20200112102124.png" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gitalk&quot;&gt;&lt;a href=&quot;#Gitalk&quot; class=&quot;headerlink&quot; title=&quot;Gitalk&quot;&gt;&lt;/a&gt;Gitalk&lt;/h1&gt;&lt;p&gt;这里只列出遇到过的问题，如未找到解决方法可到&lt;a href=&quot;https://github.com/gitalk/gitalk/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gitalk issues&lt;/a&gt; 寻找解决方法，或提出issue&lt;/p&gt;
    
    </summary>
    
      <category term="坑" scheme="http://NolotyLand.github.io/categories/%E5%9D%91/"/>
    
    
      <category term="hexo" scheme="http://NolotyLand.github.io/tags/hexo/"/>
    
      <category term="gittalk" scheme="http://NolotyLand.github.io/tags/gittalk/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="http://NolotyLand.github.io/hexo-command/"/>
    <id>http://NolotyLand.github.io/hexo-command/</id>
    <published>2019-06-11T16:00:00.000Z</published>
    <updated>2019-06-21T19:23:53.434Z</updated>
    
    <content type="html"><![CDATA[<p>  //预览草稿<br>  hexo s –draft  </p><p>  //启动hexo(等价命令, 其实就是命令简写)<br>  hexo s<br>  hexo server</p><p>  //重新生成hexo<br>  hexo g<br>  hexo generate</p><p>  //清理已生成的hexo文件<br>  hexo cl<br>  hexo clean</p><p>  //hexo部署<br>  hexo d<br>  hexo deploy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  //预览草稿&lt;br&gt;  hexo s –draft  &lt;/p&gt;
&lt;p&gt;  //启动hexo(等价命令, 其实就是命令简写)&lt;br&gt;  hexo s&lt;br&gt;  hexo server&lt;/p&gt;
&lt;p&gt;  //重新生成hexo&lt;br&gt;  hexo g&lt;br&gt;  hexo ge
      
    
    </summary>
    
      <category term="常用" scheme="http://NolotyLand.github.io/categories/%E5%B8%B8%E7%94%A8/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性</title>
    <link href="http://NolotyLand.github.io/JI-java8-new-feature/"/>
    <id>http://NolotyLand.github.io/JI-java8-new-feature/</id>
    <published>2019-06-04T16:00:00.000Z</published>
    <updated>2019-07-05T11:28:46.582Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 是 Java 语言中一个重要版本。以支持函数式编程为主，增加了不少特性，在这里简单记录一下。</p>   <a id="more"></a><h1 id="Java语言新特性"><a href="#Java语言新特性" class="headerlink" title="Java语言新特性"></a>Java语言新特性</h1><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>  可以说是进化版的匿名内部类，不仅写法上简洁优雅，性能也比匿名内部类好得多。</p><p>  书写方式:<br>  ( params ) -&gt; { statements }</p><p>  Lambda与匿名内部类写法上的对比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">                     <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Lambda expression"</span>)).start();</span><br><span class="line">             </span><br><span class="line">                     <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                             System.out.println(<span class="string">"Anonymous Class"</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;).start();</span><br><span class="line">                 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>  函数式接口是为了让Lambda表达式与Java原有功能兼容而产生的，只有一个抽象方法（但可以有多个非抽象方法），可以隐式转换为Lambda表达式。（简单来说就是可以直接用lambda表达式写接口实现，非常方便的一个功能）<br>  并且新增了 @FunctionalInterface 注解来标识函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GreetingService service = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">        service.sayMessage(<span class="string">"Lucy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>   方法引用实际上也是Lambda的一种简写形式，当Lambda调用一个已经存在的方法时，可以使用::符号来直接进行调用。</p><p>   e.g.:</p><pre><code>Order::getAmount</code></pre><h3 id="加强泛型类型推断"><a href="#加强泛型类型推断" class="headerlink" title="加强泛型类型推断"></a>加强泛型类型推断</h3><h3 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h3><p>   java8允许同一个地方多次使用同一个注解（使用@Repeatable）</p><h3 id="扩展注解支持"><a href="#扩展注解支持" class="headerlink" title="扩展注解支持"></a>扩展注解支持</h3><p>   可以将注解应用在任何地方</p><h1 id="java编译器新特性"><a href="#java编译器新特性" class="headerlink" title="java编译器新特性"></a>java编译器新特性</h1><h3 id="通过反射获取真实参数名"><a href="#通过反射获取真实参数名" class="headerlink" title="通过反射获取真实参数名"></a>通过反射获取真实参数名</h3><h1 id="java类库新特性"><a href="#java类库新特性" class="headerlink" title="java类库新特性"></a>java类库新特性</h1><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>  Stream API 将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。Stream本身并不储存数据，仅做计算操作。</p><h3 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h3><p>  新增的线程安全日期类。简单，优雅，线程安全。能用就用。</p><h3 id="Base64-API"><a href="#Base64-API" class="headerlink" title="Base64 API"></a>Base64 API</h3><p>  将Base64编码的基础方法收进了java.util里。</p><h3 id="Optional-Class"><a href="#Optional-Class" class="headerlink" title="Optional Class"></a>Optional Class</h3><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。主要用来减少对null的判断代码，增加代码可读性，避免空指针异常。</p><h1 id="新的Java工具"><a href="#新的Java工具" class="headerlink" title="新的Java工具"></a>新的Java工具</h1><h3 id="Nashorn-引擎：jjs"><a href="#Nashorn-引擎：jjs" class="headerlink" title="Nashorn 引擎：jjs"></a>Nashorn 引擎：jjs</h3><p>  可以接受js源码并执行</p><h3 id="依赖分析工具-jdeps"><a href="#依赖分析工具-jdeps" class="headerlink" title="依赖分析工具 jdeps"></a>依赖分析工具 jdeps</h3><p>  用于展示包层级和类层级的Java类依赖关系的命令行工具</p><h1 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h1><h3 id="metaSpace"><a href="#metaSpace" class="headerlink" title="metaSpace"></a>metaSpace</h3><p> 使用MetaSpace代替PermGen space<br> 使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p><pre><code>使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 是 Java 语言中一个重要版本。以支持函数式编程为主，增加了不少特性，在这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="java8" scheme="http://NolotyLand.github.io/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages 建立个人博客</title>
    <link href="http://NolotyLand.github.io/hexo/"/>
    <id>http://NolotyLand.github.io/hexo/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-07-05T07:42:47.679Z</updated>
    
    <content type="html"><![CDATA[<p>  很久很久以前，自从百度把百度空间搞没了之后，便再也没碰过个人博客一类的东西，最近闲来无事又起了这个念头，出于省钱和省事的目的，博客框架选用了Hexo，站点则选用托管到Github Pages的方式。在这里记录一下建立博客的步骤。</p><p>  主流建站方式考察：    </p><table><thead><tr><th>方式</th><th>技术门槛</th><th>服务器购买</th><th>服务器配置</th><th>域名备案</th><th>访问速度</th><th>费用</th></tr></thead><tbody><tr><td>WordPress</td><td>中</td><td>需要</td><td>自行配置</td><td>可免</td><td>视服务器而定</td><td>视服务器而定</td></tr><tr><td>Jekyll</td><td>中</td><td>不用</td><td>GitHub Page</td><td>可免</td><td>较快</td><td>低</td></tr><tr><td>Hexo</td><td>中低</td><td>不用</td><td>GitHub Page</td><td>可免</td><td>较快</td><td>低</td></tr><tr><td>Ghost</td><td>低</td><td>不用</td><td>不用</td><td>可免</td><td>较快</td><td>高</td></tr><tr><td>Farbox</td><td>低</td><td>不用</td><td>不用</td><td>可免</td><td>快</td><td>中</td></tr></tbody></table>   <a id="more"></a><p>  （from <a href="https://zoomyale.com/2016/why_blogging" target="_blank" rel="noopener">https://zoomyale.com/2016/why_blogging</a> ）</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>  使用Hexo + github pages搭建博客的前置条件，安装Git和Node.js</p><p>  安装指路：<br>  <a href="https://git-scm.com/book/zh/v2/起步-安装-Git" title="Git安装" target="_blank" rel="noopener">Git安装</a><br>  <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" title="Node.js安装" target="_blank" rel="noopener">Node.js安装</a></p><p>  Git安装后，再配置下SSH登录，方便后面的操作</p><p>  上面两个前置工具搞定之后，就可以着手配置网站环境了  </p><h1 id="github-pages初始化"><a href="#github-pages初始化" class="headerlink" title="github pages初始化"></a>github pages初始化</h1><p>   要想使用Github Pages， 首先需要在<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 拥有一个账号，并且创建一个名为 你的GitHub用户名.github.io 的仓库(Repository),找不到地方的可以点<a href="https://github.com/new" title="创建仓库" target="_blank" rel="noopener">这里</a><br>   然后使用git将网站页面推送到仓库中，如果配置正确的话，推送过后，打开 <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> (username为你的用户名)，便可以看到你的站点</p><p>   如果习惯使用命令行的话，可以照抄官方教程里的命令，当然，使用前需要了解下git基本指令的意义，包括 clone add commit push pull, 这里就不再赘述。如果不习惯命令行的操作方式，也可以去官网下载一个github的客户端，使用客户端来更新网页文件。<br>   <a href="https://pages.github.com/" target="_blank" rel="noopener">github pages官方教程</a></p><p>   网站默认会解析到仓库根目录下的index.html，可以先上传一个简单的index.html页面来测试github pages是否正确配置<br>   以官方教程为例，下面这段指令执行成功之后，打开 <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> (username为你的用户名)，你就会看到一个写着”Hello World” 的页面了   </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io </span><br><span class="line">cd username.github.io</span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></code></pre><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/helloworld.png" alt></p><h1 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h1><p>   首要做的还是装软件</p><p>   安装Hexo,在终端里输入以下命令<br>   sudo npm install hexo-cli -g</p><p>   执行完毕后输入hexo -v, 展示出hexo的版本信息就是安装成功了</p><p>   之后进入到你想放置博客的路径下，使用下面的命令<br>   hexo init blog //初始化博客项目</p><p>   cd blog //进入刚刚初始化的博客目录</p><p>   hexo server //启动博客</p><p>   正常情况下，输入hexo server会打印出以下信息  </p><pre><code>INFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.  </code></pre><p>   此时在浏览器输入 localhost:4000 便能看到Hexo的HelloWorld页面<br>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/hexoHelloworld.png" alt></p><h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>  <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">官方教程</a>提供了命令方式发布文章，不过鉴于Hexo是将文件以markdown的格式保存在blog/source/_post/路径下的，所以可以直接将文章放在此文件夹内来发布，在blog/source/_post/路径下新建后缀为.md的文件，并将文章内容按照下面的格式保存进此文件，保存后，刷新 localhost:4000 页面即可看到新发布的文章  </p><pre><code>---layout:     postdate:       2019-06-01title:      How...categories: [这是分类1, 分类2]tags:    - 这是标签1    - 这是标签2---这是预览&lt;!--more--&gt;这是正文</code></pre><h1 id="部署到github-pages"><a href="#部署到github-pages" class="headerlink" title="部署到github pages"></a>部署到github pages</h1><p>   首先执行以下命令 安装部署插件   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>   然后进入hexo目录，打开config.yml， 参照下面的格式修改 deploy部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>  然后在终端输入以下命令 完成部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo -d</span><br></pre></td></tr></table></figure><p>   执行完成后，github仓库里被自动上传了hexo生成的文件，刷新<a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> ，就会看到部署成功的网页了。</p><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>上有很多可供选择的主题，这里以<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Melody</a>主题为例，执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melody</span><br></pre></td></tr></table></figure><p>  然后在目录下找到_config.yml配置文件，找到theme属性修改为melody，之后重启hexo即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: melody</span><br></pre></td></tr></table></figure><p>  需注意的是，有些主题需要依赖额外的插件，如Melody，就需要安装pug以及stylus的渲染器才可正常展示，各主题需要的插件不同，还请仔细阅读主题文档说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade hexo-renderer-stylus</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  很久很久以前，自从百度把百度空间搞没了之后，便再也没碰过个人博客一类的东西，最近闲来无事又起了这个念头，出于省钱和省事的目的，博客框架选用了Hexo，站点则选用托管到Github Pages的方式。在这里记录一下建立博客的步骤。&lt;/p&gt;
&lt;p&gt;  主流建站方式考察：    &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;技术门槛&lt;/th&gt;
&lt;th&gt;服务器购买&lt;/th&gt;
&lt;th&gt;服务器配置&lt;/th&gt;
&lt;th&gt;域名备案&lt;/th&gt;
&lt;th&gt;访问速度&lt;/th&gt;
&lt;th&gt;费用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;WordPress&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;自行配置&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;视服务器而定&lt;/td&gt;
&lt;td&gt;视服务器而定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jekyll&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;GitHub Page&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hexo&lt;/td&gt;
&lt;td&gt;中低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;GitHub Page&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ghost&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Farbox&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Welcome to Noloty Land</title>
    <link href="http://NolotyLand.github.io/test-ariticle/"/>
    <id>http://NolotyLand.github.io/test-ariticle/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-13T15:07:53.790Z</updated>
    
    <content type="html"><![CDATA[<p> 拉普兰德梗图</p><p><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/lap.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 拉普兰德梗图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/NolotyLand/pictures/master/lap.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>

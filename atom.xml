<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Noloty Land</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://NolotyLand.github.io/"/>
  <updated>2019-06-21T19:04:28.844Z</updated>
  <id>http://NolotyLand.github.io/</id>
  
  <author>
    <name>Noloty</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>错误使用SimpleDateFormat导致的并发bug排查历程</title>
    <link href="http://NolotyLand.github.io/2019/06/21/bug-date/"/>
    <id>http://NolotyLand.github.io/2019/06/21/bug-date/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-06-21T19:04:28.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>  之前系统自动评价定时任务，偶尔会发生日期错误的现象。<br>  应该是当天评价的，但评价日期的记录却差了几个月。<br>  一开始并未在意，以为是有人处理违规或者举报评价时漏改了时间。<br>  但跟相关者闲聊时才知道，这种情形虽然不常有，但也不能算少，大概隔一两个月就会有一次用户反馈。<br>  仅是用户反馈一两个月就会有一次，未被发现的可能更多，如此稳定的出现频率，这时才令我怀疑起是程序问题。</p><h1 id="探索过程"><a href="#探索过程" class="headerlink" title="探索过程"></a>探索过程</h1><p>  首先要确认是评价创建时便有这种情况，还是创建之后其它程序修改时造成的。<br>  通过日志得知，评价时间在创建时便已经异常了。出现概率大概在1/500~1/1000。<br>  然而整个创建过程逻辑并不复杂，并未发现有什么可疑代码。</p><p>  本着先复现再排查的原则。在测试环境将此定时任务循环跑了几千条，然后不断缩小范围，发现最终原因竟然出现在创建日期使用的工具类上。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>这里写个类模拟当时的情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Date date = <span class="keyword">new</span> Date(<span class="number">1546300800000L</span>);</span><br><span class="line">                String ymd = sdf.format(date);</span><br><span class="line">                <span class="keyword">if</span>(!ymd.equals(<span class="string">"2019-01-01"</span>)) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">"get wrong date :"</span> + ymd);</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"01 thread "</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">               Date date = <span class="keyword">new</span> Date(<span class="number">1549065600000L</span>);</span><br><span class="line">               String ymd = sdf.format(date);</span><br><span class="line">               <span class="keyword">if</span>(!ymd.equals(<span class="string">"2019-02-02"</span>)) &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()  + <span class="string">"get wrong date :"</span> + ymd);</span><br><span class="line">                   System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">"02 thread "</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000000000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出：</p><pre><code>02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------01 thread get wrong date :2019-02-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------02 thread get wrong date :2019-01-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------02 thread get wrong date :2019-02-01-------------------------------------------01 thread get wrong date :2019-01-02-------------------------------------------...</code></pre><p>究其原因，是因为SimpleDateFormat类并非线程安全的类，将其定义为静态变量时，在并发情况下极有可能拿到其它线程的日期数据。<br><a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">官网文档</a>也写到，在多线程的情况下，必须在外部进行同步处理。</p><blockquote><p>Synchronization<br>  Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.</p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>两种解决方法<br>一种是将静态的SimpleDateFormat改为每次都使用新的对象，如上面格式化日期那一句改成这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1546300800000L</span>);</span><br><span class="line">String ymd = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(date);</span><br></pre></td></tr></table></figure><p>另一种是使用JDK8新提供的的日期类，使用instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat, 简单，优雅，线程安全:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.parse(<span class="string">"2019-02-02"</span>);</span><br><span class="line">String ymd = date.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br></pre></td></tr></table></figure><h1 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h1><p>这次bug排查<br> 1.犯了想当然的错误，其实这次bug已经反馈过多次，但是却想当然地认为是手工改数据导致的，如果在第一次出现这种现象时就去追查日志，这个bug也不会遗留这么久。<br> 2.对并发问题，线程安全没有足够的意识，没能第一时间想到是有线程不安全的代码造成，浪费了不少时间，只能怪自己知识积累不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h1&gt;&lt;p&gt;  之前系统自动评价定时任务，偶尔会发生日期错误的现象。&lt;br&gt;  应该是当天评价的，但评价日期的记录却差了几个月。&lt;br&gt;  一开始并未在
      
    
    </summary>
    
      <category term="bug" scheme="http://NolotyLand.github.io/categories/bug/"/>
    
    
      <category term="bug" scheme="http://NolotyLand.github.io/tags/bug/"/>
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的各种遍历方式</title>
    <link href="http://NolotyLand.github.io/2019/06/21/hashmap-traverse/"/>
    <id>http://NolotyLand.github.io/2019/06/21/hashmap-traverse/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2019-06-21T20:24:44.917Z</updated>
    
    <content type="html"><![CDATA[<p>讲真这种题在我心里跟“回字有多少种写法”差不多。<br>然而这题还是会出现。</p><p>关于性能，网上是这么说的：<br>entrySet方法一次拿到所有key和value的集合<br>而keySet拿到的只是key的集合，针对每个key，都要去Map中额外查找一次value，从而降低了总体效率<br>所以大数据量时。entrySet的方式效率更高。<br>(10w级以上才会出现明显差别，一般不考虑）<br>最优方法还是lambda表达式，简洁而且性能好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      map.put(<span class="string">"1"</span>,<span class="string">"1111"</span>);</span><br><span class="line">      map.put(<span class="string">"2"</span>,<span class="string">"2222"</span>);</span><br><span class="line">      map.put(<span class="string">"3"</span>,<span class="string">"3333"</span>);</span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 只遍历value:</span></span><br><span class="line">      <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">          System.out.println(value);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      <span class="comment">//key value都遍历:</span></span><br><span class="line">      <span class="comment">// 遍历keySet</span></span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">          System.out.println(key + <span class="string">":"</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 遍历entrySet</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">          System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      <span class="comment">// entrySet集合迭代器遍历</span></span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">          System.out.println( entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"===================="</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// forEach方法+lambda表达式（底层也是entrySet遍历）(jdk1.8+  )</span></span><br><span class="line">      map.forEach((k, v) -&gt;  System.out.println( k + <span class="string">":"</span> + v));</span><br></pre></td></tr></table></figure><p>顺带一提List和Set的遍历方式, 是一样的, 由于跟Map比起来没什么复杂度估计一般不会问到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//forEach+lambda遍历（底层就是for循环遍历）（jdk1.8+）</span></span><br><span class="line">     list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"======================"</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//for循环遍历</span></span><br><span class="line">     <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//集合迭代器遍历</span></span><br><span class="line">     Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">     <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">         System.out.println(it.next());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//forEach+lambda遍历（底层就是for循环遍历）（jdk1.8+）</span></span><br><span class="line">      set.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//for循环遍历</span></span><br><span class="line">      <span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//集合迭代器遍历</span></span><br><span class="line">      Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">          System.out.println(it.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;讲真这种题在我心里跟“回字有多少种写法”差不多。&lt;br&gt;然而这题还是会出现。&lt;/p&gt;
&lt;p&gt;关于性能，网上是这么说的：&lt;br&gt;entrySet方法一次拿到所有key和value的集合&lt;br&gt;而keySet拿到的只是key的集合，针对每个key，都要去Map中额外查找一次va
      
    
    </summary>
    
      <category term="面试" scheme="http://NolotyLand.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="java" scheme="http://NolotyLand.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo中markdown文件生成的HTML页面白屏</title>
    <link href="http://NolotyLand.github.io/2019/06/14/hexo-fix-whitescreen/"/>
    <id>http://NolotyLand.github.io/2019/06/14/hexo-fix-whitescreen/</id>
    <published>2019-06-13T16:00:00.000Z</published>
    <updated>2019-06-14T21:19:05.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象·起因"><a href="#现象·起因" class="headerlink" title="现象·起因"></a>现象·起因</h2><p>   写了几篇文章草稿，本地测试发布发现偶尔会有文章页面白屏，无法加载出任何内容。有时删除或者增加一些字会能够正常加载页面。</p><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/white.png" alt></p><p>   一开始以为是文章内容里有特殊符号与页面渲染插件冲突造成的，但排查了文章内容后，并未发现有比较特殊的符号。<br>   删除一些文字能够正常渲染页面，但这些文字并无特殊之处。</p><p>   检查页面源代码时，终于发现原因，原来出问题的页面代码未加载完就被截断了。</p><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/20190614015626.png" alt></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>   参考 <a href="https://molunerfinn.com/make-a-hexo-theme/#Bug%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3" target="_blank" rel="noopener">Hexo主题开发经验杂谈</a><br>   此问题属于hexo的bug，在中文字符过多时会有几率显现。<br>   在hexo目录下的_config.yml里添加如下配置可以避免：</p><pre><code class="yml"><span class="attr">server:</span><span class="attr">  compress:</span> <span class="literal">true</span> <span class="comment"># 开启压缩</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现象·起因&quot;&gt;&lt;a href=&quot;#现象·起因&quot; class=&quot;headerlink&quot; title=&quot;现象·起因&quot;&gt;&lt;/a&gt;现象·起因&lt;/h2&gt;&lt;p&gt;   写了几篇文章草稿，本地测试发布发现偶尔会有文章页面白屏，无法加载出任何内容。有时删除或者增加一些字会能够正常加
      
    
    </summary>
    
      <category term="坑" scheme="http://NolotyLand.github.io/categories/%E5%9D%91/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="hexo" scheme="http://NolotyLand.github.io/tags/hexo/"/>
    
      <category term="fix" scheme="http://NolotyLand.github.io/tags/fix/"/>
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="http://NolotyLand.github.io/2019/06/12/hexo-command/"/>
    <id>http://NolotyLand.github.io/2019/06/12/hexo-command/</id>
    <published>2019-06-11T16:00:00.000Z</published>
    <updated>2019-06-21T19:23:53.434Z</updated>
    
    <content type="html"><![CDATA[<p>  //预览草稿<br>  hexo s –draft  </p><p>  //启动hexo(等价命令, 其实就是命令简写)<br>  hexo s<br>  hexo server</p><p>  //重新生成hexo<br>  hexo g<br>  hexo generate</p><p>  //清理已生成的hexo文件<br>  hexo cl<br>  hexo clean</p><p>  //hexo部署<br>  hexo d<br>  hexo deploy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  //预览草稿&lt;br&gt;  hexo s –draft  &lt;/p&gt;
&lt;p&gt;  //启动hexo(等价命令, 其实就是命令简写)&lt;br&gt;  hexo s&lt;br&gt;  hexo server&lt;/p&gt;
&lt;p&gt;  //重新生成hexo&lt;br&gt;  hexo g&lt;br&gt;  hexo ge
      
    
    </summary>
    
      <category term="常用" scheme="http://NolotyLand.github.io/categories/%E5%B8%B8%E7%94%A8/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性</title>
    <link href="http://NolotyLand.github.io/2019/06/05/java8-new-feature/"/>
    <id>http://NolotyLand.github.io/2019/06/05/java8-new-feature/</id>
    <published>2019-06-04T16:00:00.000Z</published>
    <updated>2019-06-13T17:16:29.299Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 是 Java 语言中一个重要版本。以支持函数式编程为主，增加了不少特性，在这里简单记录一下。</p>   <a id="more"></a><h1 id="Java语言新特性"><a href="#Java语言新特性" class="headerlink" title="Java语言新特性"></a>Java语言新特性</h1><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>  可以说是进化版的匿名内部类，不仅写法上简洁优雅，性能也比匿名内部类好得多。</p><p>  书写方式:<br>  ( params ) -&gt; { statements }</p><p>  Lambda与匿名内部类写法上的对比:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              </span><br><span class="line">                     <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Lambda expression"</span>)).start();</span><br><span class="line">             </span><br><span class="line">                     <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                             System.out.println(<span class="string">"Anonymous Class"</span>);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;).start();</span><br><span class="line">                 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>  函数式接口是为了让Lambda表达式与Java原有功能兼容而产生的，只有一个抽象方法（但可以有多个非抽象方法），可以隐式转换为Lambda表达式。（简单来说就是可以直接用lambda表达式写接口实现，非常方便的一个功能）<br>  并且新增了 @FunctionalInterface 注解来标识函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GreetingService service = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">        service.sayMessage(<span class="string">"Lucy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>   方法引用实际上也是Lambda的一种简写形式，当Lambda调用一个已经存在的方法时，可以使用::符号来直接进行调用。</p><p>   e.g.:</p><pre><code>Order::getAmount</code></pre><h3 id="加强泛型类型推断"><a href="#加强泛型类型推断" class="headerlink" title="加强泛型类型推断"></a>加强泛型类型推断</h3><h3 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h3><p>   java8允许同一个地方多次使用同一个注解（使用@Repeatable）</p><h3 id="扩展注解支持"><a href="#扩展注解支持" class="headerlink" title="扩展注解支持"></a>扩展注解支持</h3><p>   可以将注解应用在任何地方</p><h1 id="java编译器新特性"><a href="#java编译器新特性" class="headerlink" title="java编译器新特性"></a>java编译器新特性</h1><h3 id="通过反射获取真实参数名"><a href="#通过反射获取真实参数名" class="headerlink" title="通过反射获取真实参数名"></a>通过反射获取真实参数名</h3><h1 id="java类库新特性"><a href="#java类库新特性" class="headerlink" title="java类库新特性"></a>java类库新特性</h1><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>  Stream API 将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。Stream本身并不储存数据，仅做计算操作。</p><h3 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h3><h3 id="Base64-API"><a href="#Base64-API" class="headerlink" title="Base64 API"></a>Base64 API</h3><p>  将Base64编码的基础方法收进了java.util里。</p><h3 id="Optional-Class"><a href="#Optional-Class" class="headerlink" title="Optional Class"></a>Optional Class</h3><p>  Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。主要用来减少对null的判断代码，增加代码可读性，避免空指针异常。</p><h1 id="新的Java工具"><a href="#新的Java工具" class="headerlink" title="新的Java工具"></a>新的Java工具</h1><h3 id="Nashorn-引擎：jjs"><a href="#Nashorn-引擎：jjs" class="headerlink" title="Nashorn 引擎：jjs"></a>Nashorn 引擎：jjs</h3><p>  可以接受js源码并执行</p><h3 id="依赖分析工具-jdeps"><a href="#依赖分析工具-jdeps" class="headerlink" title="依赖分析工具 jdeps"></a>依赖分析工具 jdeps</h3><p>  用于展示包层级和类层级的Java类依赖关系的命令行工具</p><h1 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h1><h3 id="metaSpace"><a href="#metaSpace" class="headerlink" title="metaSpace"></a>metaSpace</h3><p> 使用MetaSpace代替PermGen space<br> 使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p><pre><code>使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 是 Java 语言中一个重要版本。以支持函数式编程为主，增加了不少特性，在这里简单记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hide" scheme="http://NolotyLand.github.io/tags/hide/"/>
    
      <category term="java8" scheme="http://NolotyLand.github.io/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages 建立个人博客</title>
    <link href="http://NolotyLand.github.io/2019/06/01/hexo/"/>
    <id>http://NolotyLand.github.io/2019/06/01/hexo/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-14T21:07:26.908Z</updated>
    
    <content type="html"><![CDATA[<p>  很久很久以前，自从百度把百度空间搞没了之后，便再也没碰过个人博客一类的东西，最近又起了这个念头，出于省钱和省事的目的，博客框架选用了Hexo，站点则选用托管到Github Pages的方式。在这里记录一下建立博客的步骤。</p><p>  主流建站方式考察：    </p><table><thead><tr><th>方式</th><th>技术门槛</th><th>服务器购买</th><th>服务器配置</th><th>域名备案</th><th>访问速度</th><th>费用</th></tr></thead><tbody><tr><td>WordPress</td><td>中</td><td>需要</td><td>自行配置</td><td>可免</td><td>视服务器而定</td><td>视服务器而定</td></tr><tr><td>Jekyll</td><td>中</td><td>不用</td><td>GitHub Page</td><td>可免</td><td>较快</td><td>低</td></tr><tr><td>Hexo</td><td>中低</td><td>不用</td><td>GitHub Page</td><td>可免</td><td>较快</td><td>低</td></tr><tr><td>Ghost</td><td>低</td><td>不用</td><td>不用</td><td>可免</td><td>较快</td><td>高</td></tr><tr><td>Farbox</td><td>低</td><td>不用</td><td>不用</td><td>可免</td><td>快</td><td>中</td></tr></tbody></table>   <a id="more"></a><p>  （from <a href="https://zoomyale.com/2016/why_blogging" target="_blank" rel="noopener">https://zoomyale.com/2016/why_blogging</a> ）</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>  使用Hexo + github pages搭建博客的前置条件，安装Git和Node.js</p><p>  安装指路：<br>  <a href="https://git-scm.com/book/zh/v2/起步-安装-Git" title="Git安装" target="_blank" rel="noopener">Git安装</a><br>  <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" title="Node.js安装" target="_blank" rel="noopener">Node.js安装</a></p><p>  Git安装后，再配置下SSH登录，方便后面的操作</p><p>  上面两个前置工具搞定之后，就可以着手配置网站环境了  </p><h1 id="github-pages初始化"><a href="#github-pages初始化" class="headerlink" title="github pages初始化"></a>github pages初始化</h1><p>   要想使用Github Pages， 首先需要在<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 拥有一个账号，并且创建一个名为 你的GitHub用户名.github.io 的仓库(Repository),找不到地方的可以点<a href="https://github.com/new" title="创建仓库" target="_blank" rel="noopener">这里</a><br>   然后使用git将网站页面推送到仓库中，如果配置正确的话，推送过后，打开 <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> (username为你的用户名)，便可以看到你的站点</p><p>   如果习惯使用命令行的话，可以照抄官方教程里的命令，当然，使用前需要了解下git基本指令的意义，包括 clone add commit push pull, 这里就不再赘述。如果不习惯命令行的操作方式，也可以去官网下载一个github的客户端，使用客户端来更新网页文件。<br>   <a href="https://pages.github.com/" target="_blank" rel="noopener">github pages官方教程</a></p><p>   网站默认会解析到仓库根目录下的index.html，可以先上传一个简单的index.html页面来测试github pages是否正确配置<br>   以官方教程为例，下面这段指令执行成功之后，打开 <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> (username为你的用户名)，你就会看到一个写着”Hello World” 的页面了   </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io </span><br><span class="line">cd username.github.io</span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></code></pre><p>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/helloworld.png" alt></p><h1 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h1><p>   首要做的还是装软件</p><p>   安装Hexo,在终端里输入以下命令<br>   sudo npm install hexo-cli -g</p><p>   执行完毕后输入hexo -v, 展示出hexo的版本信息就是安装成功了</p><p>   之后进入到你想放置博客的路径下，使用下面的命令<br>   hexo init blog //初始化博客项目</p><p>   cd blog //进入刚刚初始化的博客目录</p><p>   hexo server //启动博客</p><p>   正常情况下，输入hexo server会打印出以下信息  </p><pre><code>INFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.  </code></pre><p>   此时在浏览器输入 localhost:4000 便能看到Hexo的HelloWorld页面<br>   <img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/hexoHelloworld.png" alt></p><h1 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h1><p>  <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">官方教程</a>提供了命令方式发布文章，不过鉴于Hexo是将文件以markdown的格式保存在blog/source/_post/路径下的，所以可以直接将文章放在此文件夹内来发布，在blog/source/_post/路径下新建后缀为.md的文件，并将文章内容按照下面的格式保存进此文件，保存后，刷新 localhost:4000 页面即可看到新发布的文章  </p><pre><code>---layout:     postdate:       2019-06-01title:      How...categories: [这是分类1, 分类2]tags:    - 这是标签1    - 这是标签2---这是预览&lt;!--more--&gt;这是正文</code></pre><h1 id="部署到github-pages"><a href="#部署到github-pages" class="headerlink" title="部署到github pages"></a>部署到github pages</h1><p>   首先执行以下命令 安装部署插件   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>   然后进入hexo目录，打开config.yml， 参照下面的格式修改 deploy部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>  然后在终端输入以下命令 完成部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo -d</span><br></pre></td></tr></table></figure><p>   执行完成后，github仓库里被自动上传了hexo生成的文件，刷新<a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> ，就会看到部署成功的网页了。</p><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网</a>上有很多可供选择的主题，这里以<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Melody</a>主题为例，执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/Molunerfinn/hexo-theme-melody themes/melody</span><br></pre></td></tr></table></figure><p>  然后在目录下找到_config.yml配置文件，找到theme属性修改为melody，之后重启hexo即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: melody</span><br></pre></td></tr></table></figure><p>  需注意的是，有些主题需要依赖额外的插件，如Melody，就需要安装pug以及stylus的渲染器才可正常展示，各主题需要的插件不同，还请仔细阅读主题文档说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade hexo-renderer-stylus</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  很久很久以前，自从百度把百度空间搞没了之后，便再也没碰过个人博客一类的东西，最近又起了这个念头，出于省钱和省事的目的，博客框架选用了Hexo，站点则选用托管到Github Pages的方式。在这里记录一下建立博客的步骤。&lt;/p&gt;
&lt;p&gt;  主流建站方式考察：    &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;技术门槛&lt;/th&gt;
&lt;th&gt;服务器购买&lt;/th&gt;
&lt;th&gt;服务器配置&lt;/th&gt;
&lt;th&gt;域名备案&lt;/th&gt;
&lt;th&gt;访问速度&lt;/th&gt;
&lt;th&gt;费用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;WordPress&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;自行配置&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;视服务器而定&lt;/td&gt;
&lt;td&gt;视服务器而定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jekyll&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;GitHub Page&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hexo&lt;/td&gt;
&lt;td&gt;中低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;GitHub Page&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ghost&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;较快&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Farbox&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;不用&lt;/td&gt;
&lt;td&gt;可免&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://NolotyLand.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Welcome to Noloty Land</title>
    <link href="http://NolotyLand.github.io/2019/06/01/test-ariticle/"/>
    <id>http://NolotyLand.github.io/2019/06/01/test-ariticle/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-13T15:07:53.790Z</updated>
    
    <content type="html"><![CDATA[<p> 拉普兰德梗图</p><p><img src="https://raw.githubusercontent.com/NolotyLand/pictures/master/lap.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 拉普兰德梗图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/NolotyLand/pictures/master/lap.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
